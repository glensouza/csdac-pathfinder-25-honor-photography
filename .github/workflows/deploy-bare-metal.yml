name: Deploy to Bare Metal Server
permissions:
  contents: read

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
  workflow_dispatch:

env:
  DOTNET_VERSION: '9.0.x'
  PUBLISH_DIR: './publish'
  DEPLOY_DIR: '/opt/pathfinder-photography'
  SERVICE_NAME: 'pathfinder-photography'

# Ensure only the latest run for a given branch proceeds; cancel previous in-progress/queued runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      build_number: ${{ steps.set_build_number.outputs.build_number }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Set Build Number (daily counter)
        id: set_build_number
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          DATE=$(date +'%Y%m%d')

          echo "Counting existing releases for date $DATE..."

          # Fetch recent releases (first 100)
          RELEASES_JSON=$(curl -s -H "Accept: application/vnd.github+json" -H "Authorization: Bearer $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases?per_page=100")

          # Extract tag_name values without requiring jq
          TAGS=$(echo "$RELEASES_JSON" | grep -oP '"tag_name"\s*:\s*"\K[^"]+')

          # Count tags that start with DATE.
          COUNT=0
          if [ -n "$TAGS" ]; then
            COUNT=$(echo "$TAGS" | grep -E "^${DATE}\." | wc -l | tr -d ' ')
          fi

          # Increment for this build
          NEXT=$((COUNT + 1))
          BUILD_NUMBER="${DATE}.${NEXT}"

          echo "Computed BUILD_NUMBER=$BUILD_NUMBER"
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

      - name: Restore dependencies
        run: dotnet restore PathfinderPhotography.csproj
      
      - name: Build application
        run: dotnet build PathfinderPhotography.csproj -c Release --no-restore
      
      - name: Publish application
        run: dotnet publish PathfinderPhotography.csproj -c Release -o ${{ env.PUBLISH_DIR }} --no-build
      
      - name: Create deployment archive
        run: |
          cd ${{ env.PUBLISH_DIR }}
          # create tar in repository root for easier reuse across steps
          tar -czf ../pathfinder-photography-${{ env.BUILD_NUMBER }}.tar.gz .
          cd ..
          sha256sum pathfinder-photography-${{ env.BUILD_NUMBER }}.tar.gz > pathfinder-photography-${{ env.BUILD_NUMBER }}.tar.gz.sha256
      
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: pathfinder-photography-build
          path: |
            pathfinder-photography-${{ env.BUILD_NUMBER }}.tar.gz
            pathfinder-photography-${{ env.BUILD_NUMBER }}.tar.gz.sha256
          retention-days: 30

      - name: Install GitHub CLI
        run: |
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y gh
          else
            echo "gh already installed"
          fi

      # Note: don't run 'gh auth login' when GITHUB_TOKEN is present; use GH_TOKEN env var for non-interactive auth
      - name: Create Release and upload asset with gh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME=${{ env.BUILD_NUMBER }}
          ASSET=pathfinder-photography-${{ env.BUILD_NUMBER }}.tar.gz

          echo "Creating release $TAG_NAME and uploading asset $ASSET"

          # Generate release notes dynamically from git commits.
          # If a previous tag exists, use commits since that tag; otherwise include the last 20 commits.
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            PREV_TAG=$(git describe --tags --abbrev=0)
            echo "Found previous tag: $PREV_TAG"
            NOTES=$(git log --pretty=format:'- %s (%h)' "$PREV_TAG"..HEAD)
          else
            echo "No previous tag found, using last 20 commits"
            NOTES=$(git log -n 20 --pretty=format:'- %s (%h)')
          fi

          if [ -z "$NOTES" ]; then
            NOTES="No notable changes"
          fi

          # Create or update release and upload the asset
          if gh release view "$TAG_NAME" --repo "${{ github.repository }}" >/dev/null 2>&1; then
            echo "Release $TAG_NAME already exists. Uploading asset."
            gh release upload "$TAG_NAME" "$ASSET" --repo "${{ github.repository }}" --clobber
          else
            gh release create "$TAG_NAME" "$ASSET" --title "Release $TAG_NAME" --notes "$NOTES" --repo "${{ github.repository }}"
          fi

  deploy:
    name: Deploy to Server
    needs: build
    runs-on: self-hosted
    environment: 
      name: production
      url: https://pathfinder.coronasda.church
    
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: pathfinder-photography-build
      
      - name: Set Build Number
        run: |
          echo "BUILD_NUMBER=${{ needs.build.outputs.build_number }}" >> $GITHUB_ENV
      
      - name: Verify artifact checksum
        run: |
          echo "Verifying deployment artifact integrity..."
          if sha256sum -c pathfinder-photography-${{ env.BUILD_NUMBER }}.tar.gz.sha256; then
            echo "✅ Checksum verified - artifact integrity confirmed"
          else
            echo "❌ Checksum verification failed - artifact may be corrupted"
            exit 1
          fi
      
      - name: Create backup of current deployment
        run: |
          if [ -d "${{ env.DEPLOY_DIR }}" ]; then
            BACKUP_DIR="/opt/backups/pathfinder-photography/deployments"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            
            # Create backup directory
            sudo -n /usr/bin/mkdir -p $BACKUP_DIR
            
            echo "Creating backup at $BACKUP_DIR/backup_$TIMESTAMP.tar.gz"
            
            # Create backup (pathfinder user runs the runner and owns the files)
            sudo -n /usr/bin/tar -czf $BACKUP_DIR/backup_$TIMESTAMP.tar.gz -C ${{ env.DEPLOY_DIR }} .
            
            # Set ownership of the backup file to pathfinder for consistency
            sudo -n /usr/bin/chown pathfinder:pathfinder $BACKUP_DIR/backup_$TIMESTAMP.tar.gz
            
            # Keep only last 5 backups using find for safer sudo access
            OLD_BACKUPS=$(sudo -n /usr/bin/find $BACKUP_DIR -name 'backup_*.tar.gz' -type f -printf '%T@ %p\n' | sort -rn | tail -n +6 | cut -d' ' -f2-)
            if [ -n "$OLD_BACKUPS" ]; then
              echo "$OLD_BACKUPS" | while read backup_file; do
                sudo -n /usr/bin/rm -f "$backup_file"
              done
            fi
            
            echo "Backup created successfully"
          else
            echo "No existing deployment to backup"
          fi
      
      - name: Stop application service
        run: |
          echo "Stopping ${{ env.SERVICE_NAME }} service..."
          # Runner runs as pathfinder user with passwordless sudo configured
          sudo -n /usr/bin/systemctl stop ${{ env.SERVICE_NAME }}
          echo "Service stopped successfully"
      
      - name: Deploy application
        run: |
          # Print ownership and permissions for deployment dir before deploy:
          ls -la ${{ env.DEPLOY_DIR }} || true

          echo "Deploying to ${{ env.DEPLOY_DIR }}..."
          sudo -n /usr/bin/mkdir -p ${{ env.DEPLOY_DIR }}
          
          # Extract new version
          sudo -n /usr/bin/tar -xzf pathfinder-photography-${{ env.BUILD_NUMBER }}.tar.gz -C ${{ env.DEPLOY_DIR }}
          
          # Set correct ownership for deployed files (pathfinder user owns everything)
          sudo -n /usr/bin/chown -R pathfinder:pathfinder ${{ env.DEPLOY_DIR }}
                    
          echo "Deployment completed successfully"
      
      - name: Start application service
        run: |
          echo "Starting ${{ env.SERVICE_NAME }} service..."
          echo "Running: sudo -n /usr/bin/systemctl start ${{ env.SERVICE_NAME }}"
          sudo -n /usr/bin/systemctl start ${{ env.SERVICE_NAME }}
          echo "Service start command executed"

          # Wait a short period for the service to become active
          sleep 5
        
          # Check if service is running
          if sudo -n /usr/bin/systemctl is-active --quiet ${{ env.SERVICE_NAME }}; then
              echo "Service started successfully"
          else
              echo "Service failed to start. Checking logs..."
              sudo -n /usr/bin/journalctl -u ${{ env.SERVICE_NAME }} -n50 --no-pager || true
              exit 1
          fi
      
      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          
          # Wait for application to be ready
          for i in {1..30}; do
            if curl -f -s http://localhost:5000/alive > /dev/null 2>&1; then
              echo "Application is responding on /alive endpoint"
              break
            fi
            echo "Waiting for application to start... ($i/30)"
            sleep 2
          done
          
          # Final health check
          if curl -f -s http://localhost:5000/alive > /dev/null 2>&1; then
            echo "✅ Deployment verification successful"
            echo "Application is healthy and responding"
          else
            echo "❌ Deployment verification failed"
            echo "Application is not responding on health endpoint"
            journalctl -u ${{ env.SERVICE_NAME }} -n100 --no-pager || true
            exit 1
          fi
      
      - name: Reload Nginx
        run: |
          echo "Reloading Nginx configuration..."
          sudo -n /usr/sbin/nginx -t && sudo -n /usr/bin/systemctl reload nginx || echo "nginx reload failed"
      
      - name: Create deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** production" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed to:** ${{ env.DEPLOY_DIR }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Service:** ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ✅ Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Service Status" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
          sudo -n systemctl status ${{ env.SERVICE_NAME }} --no-pager || true >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
      
      - name: Cleanup old artifacts
        if: always()
        run: |
          rm -f pathfinder-photography-*.tar.gz*
          echo "Cleaned up deployment artifacts"

  rollback:
    name: Rollback on Failure
    needs: deploy
    if: failure()
    runs-on: self-hosted
    permissions:
      contents: read
    
    steps:
      - name: Find latest backup
        id: find_backup
        run: |
          BACKUP_DIR="/opt/backups/pathfinder-photography/deployments"
          LATEST_BACKUP=$(ls -t $BACKUP_DIR/backup_*.tar.gz 2>/dev/null | head -n 1)
          if [ -n "$LATEST_BACKUP" ]; then
            echo "backup_file=$LATEST_BACKUP" >> $GITHUB_OUTPUT
            echo "Found backup: $LATEST_BACKUP"
          else
            echo "No backup found"
            exit 1
          fi
      
      - name: Restore from backup
        if: steps.find_backup.outputs.backup_file != ''
        run: |
          echo "Rolling back to backup: ${{ steps.find_backup.outputs.backup_file }}"
          
          # Stop service
          sudo -n /usr/bin/systemctl stop ${{ env.SERVICE_NAME }}
          
          # Restore backup
          sudo -n /usr/bin/tar -xzf ${{ steps.find_backup.outputs.backup_file }} -C ${{ env.DEPLOY_DIR }}
          
          # Set correct ownership after restore
          sudo -n chown -R pathfinder:pathfinder ${{ env.DEPLOY_DIR }}
          
          # Start service
          sudo -n /usr/bin/systemctl start ${{ env.SERVICE_NAME }}
          
          echo "Rollback completed"
      
      - name: Verify rollback
        run: |
          sleep 5
          if sudo -n /usr/bin/systemctl is-active --quiet ${{ env.SERVICE_NAME }}; then
            echo "✅ Rollback successful - service is running"
          else
            echo "❌ Rollback failed - service is not running"
            sudo -n /usr/bin/journalctl -u ${{ env.SERVICE_NAME }} -n 50 --no-pager
            exit 1
          fi

  notify:
    name: Send Notification
    needs: [build, deploy]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Create notification summary
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "status=✅ Deployment Successful" >> $GITHUB_ENV
            echo "color=success" >> $GITHUB_ENV
          else
            echo "status=❌ Deployment Failed" >> $GITHUB_ENV
            echo "color=danger" >> $GITHUB_ENV
          fi
      
      - name: Deployment result
        run: |
          echo "### ${{ env.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- Branch: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- Workflow: ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "- Run: ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY